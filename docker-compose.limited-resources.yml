# docker-compose.limited-resources.yml
# Конфигурация для имитации сервера с ограниченными ресурсами:
# CPU: 1 vCore (1 виртуальное ядро)
# RAM: 2 GB

services:
  db:
    image: postgres:15-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data/
      - ./db_backup:/backups
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_INITDB_ARGS=--encoding=UTF8 --locale=C.UTF-8
    ports:
      - "5433:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 15s  # Увеличено для экономии ресурсов
      timeout: 10s
      retries: 3
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '0.4'  # 40% от 1 vCore для базы данных
          memory: 512M  # 512 MB для PostgreSQL
        reservations:
          cpus: '0.2'  # Минимум 20% CPU
          memory: 256M  # Минимум 256 MB RAM
    # Оптимизация PostgreSQL для ограниченных ресурсов
    command: >
      postgres
      -c shared_buffers=128MB
      -c effective_cache_size=256MB
      -c maintenance_work_mem=64MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=4MB
      -c min_wal_size=1GB
      -c max_wal_size=4GB
      -c max_worker_processes=2
      -c max_parallel_workers_per_gather=1
      -c max_parallel_workers=2
      -c max_parallel_maintenance_workers=1

  backend:
    build:
      context: ./RentalApp_FASTAPI
      dockerfile: Dockerfile.backend
    volumes:
      - ./RentalApp_FASTAPI:/app
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql+asyncpg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}
      - CSRF_SECRET_KEY=${CSRF_SECRET_KEY}
      - TELEGRAM_TOKEN=${TELEGRAM_TOKEN}
      - DEFAULT_TELEGRAM_CHAT_ID=${DEFAULT_TELEGRAM_CHAT_ID}
      - DEBUG=${DEBUG}
      - YANDEX_EMAIL_SENDER=${YANDEX_EMAIL_SENDER}
      - YANDEX_SMTP_PASSWORD=${YANDEX_SMTP_PASSWORD}
      - DB_TYPE=${DB_TYPE}
      - SECRET_KEY=${SECRET_KEY}
      - TZ=Europe/Astrakhan
      # Оптимизация для ограниченных ресурсов
      - WORKERS=1  # Один worker для экономии памяти
      - MAX_REQUESTS=1000  # Перезапуск worker после 1000 запросов
      - MAX_REQUESTS_JITTER=100
    depends_on:
      db:
        condition: service_healthy
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '0.4'  # 40% от 1 vCore для backend
          memory: 768M  # 768 MB для FastAPI приложения
        reservations:
          cpus: '0.2'  # Минимум 20% CPU
          memory: 384M  # Минимум 384 MB RAM

  # Диагностические тесты
  diagnostics:
    build:
      context: ./RentalApp_FASTAPI
      dockerfile: Dockerfile.backend
    volumes:
      - ./RentalApp_FASTAPI:/app
    environment:
      - DATABASE_URL=postgresql+asyncpg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}
      - CSRF_SECRET_KEY=${CSRF_SECRET_KEY}
      - TELEGRAM_TOKEN=${TELEGRAM_TOKEN}
      - DEFAULT_TELEGRAM_CHAT_ID=${DEFAULT_TELEGRAM_CHAT_ID}
      - DEBUG=${DEBUG}
      - YANDEX_EMAIL_SENDER=${YANDEX_EMAIL_SENDER}
      - YANDEX_SMTP_PASSWORD=${YANDEX_SMTP_PASSWORD}
      - DB_TYPE=${DB_TYPE}
      - SECRET_KEY=${SECRET_KEY}
      - TZ=Europe/Astrakhan
    depends_on:
      db:
        condition: service_healthy
      backend:
        condition: service_started
    command: python scripts/run_diagnostics.py
    profiles:
      - diagnostics
    deploy:
      resources:
        limits:
          cpus: '0.1'  # 10% от 1 vCore для диагностики
          memory: 128M  # 128 MB для диагностических тестов
        reservations:
          cpus: '0.05'  # Минимум 5% CPU
          memory: 64M  # Минимум 64 MB RAM
        
  frontend:
    build:
      context: ./rental-app-main
      dockerfile: Dockerfile.frontend
    ports:
      - "5173:80"  # Vite dev server порт для разработки
    volumes:
      - ./rental-app-main/nginx/nginx.dev.conf:/etc/nginx/conf.d/default.conf
      - ./letsencrypt:/etc/letsencrypt
      - ./ssl:/etc/nginx/ssl
    environment:
      - DOMAIN=localhost
      - SSL_EMAIL=
    depends_on:
      - backend
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '0.2'  # 20% от 1 vCore для nginx
          memory: 256M  # 256 MB для nginx
        reservations:
          cpus: '0.1'  # Минимум 10% CPU
          memory: 128M  # Минимум 128 MB RAM
    # Оптимизация nginx для ограниченных ресурсов будет применена через конфигурационный файл

  # Certbot для автоматического получения SSL сертификатов
  certbot:
    image: certbot/certbot
    volumes:
      - ./letsencrypt:/etc/letsencrypt
      - ./ssl:/etc/nginx/ssl
    command: >
      sh -c "
        if [ -n '${DOMAIN:-}' ] && [ -n '${SSL_EMAIL:-}' ]; then
          echo 'Настройка SSL для домена: ${DOMAIN}';
          certbot certonly --webroot --webroot-path=/etc/nginx/ssl --email ${SSL_EMAIL} --agree-tos --no-eff-email -d ${DOMAIN};
        else
          echo 'Режим разработки - SSL не настраивается';
          tail -f /dev/null;
        fi
      "
    depends_on:
      - frontend
    profiles:
      - ssl
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '0.05'  # 5% от 1 vCore для certbot
          memory: 64M  # 64 MB для certbot
        reservations:
          cpus: '0.02'  # Минимум 2% CPU
          memory: 32M  # Минимум 32 MB RAM

  # Сервис для автоматических бэкапов (опциональный)
  db-backup:
    image: postgres:15-alpine
    volumes:
      - ./db_backup:/backups
      - ./scripts:/scripts
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    profiles:
      - backup
    command: >
      sh -c "
        echo 'Сервис бэкапов запущен. Для создания бэкапа используйте:';
        echo 'docker-compose exec db pg_dump -U myuser -d rental_db --clean --if-exists --create > /backups/rental_db_backup_\$(date +%Y%m%d_%H%M%S).sql';
        echo 'Ожидание...';
        tail -f /dev/null
      "
    deploy:
      resources:
        limits:
          cpus: '0.05'  # 5% от 1 vCore для бэкапов
          memory: 64M  # 64 MB для сервиса бэкапов
        reservations:
          cpus: '0.02'  # Минимум 2% CPU
          memory: 32M  # Минимум 32 MB RAM

volumes:
  postgres_data:
